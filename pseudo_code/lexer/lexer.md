# lexer.c 疑似コード

## 関数: handle_quotes
- **引数**:
  - `input`: 入力文字列
  - `i`: 現在のインデックスへのポインタ
  - `quote_char`: クォート文字 (' または ")
- **処理**:
  1. 開始位置 `start` を保存し、インデックスをインクリメントする。
  2. 閉じクォートが見つかるまでインデックスを進める。
  3. クォートの中身を部分文字列として抽出する。
  4. 閉じクォートがあればインデックスをインクリメントする。
  5. 抽出した文字列を返す。

## 関数: handle_word
- **引数**:
  - `input`: 入力文字列
  - `i`: 現在のインデックスへのポインタ
- **処理**:
  1. 開始位置 `start` を保存する。
  2. 空白、パイプ、リダイレクト、クォート以外の文字が続く間、インデックスを進める。
  3. 抽出した部分文字列を返す。

## 関数: handle_redirect
- **引数**:
  - `input`: 入力文字列
  - `i`: 現在のインデックスへのポインタ
  - `tokens`: トークンリストへのポインタ
- **処理**:
  1. `<` の場合:
     - 次の文字も `<` なら `<<` (HEREDOC) トークンを追加し、インデックスを2進める。
     - そうでなければ `<` (REDIR_IN) トークンを追加し、インデックスを1進める。
  2. `>` の場合:
     - 次の文字も `>` なら `>>` (REDIR_APPEND) トークンを追加し、インデックスを2進める。
     - そうでなければ `>` (REDIR_OUT) トークンを追加し、インデックスを1進める。

## 関数: build_combined_word
- **引数**:
  - `input`: 入力文字列
  - `i`: 現在のインデックスへのポインタ
  - `quote_type`: クォートタイプを格納するポインタ
  - `data`: シェルの主要データ構造体
- **処理**:
  1. 結果文字列 `result` を空文字で初期化する。
  2. 区切り文字（空白、パイプ、リダイレクト）以外が続く間ループする:
     - `'` の場合: `handle_quotes` で抽出し、`first_quote` を記録する。
     - `"` の場合: `handle_quotes` で抽出し、`expand_variables` で展開し、`first_quote` を記録する。
     - その他の文字の場合: `handle_word` で抽出し、`expand_variables` で展開し、`has_unquoted` フラグを立てる。
     - 抽出した部分を `result` に結合する。
  3. `has_unquoted` が真なら `quote_type` を `0` に、そうでなければ `first_quote` に設定する。
  4. `result` を返す。

## 関数: process_token
- **引数**:
  - `input`: 入力文字列
  - `i`: 現在のインデックスへのポインタ
  - `tokens`: トークンリストへのポインタ
  - `data`: シェルの主要データ構造体
- **処理**:
  1. `|` の場合: パイプトークンを追加し、インデックスを進める。
  2. `<` または `>` の場合: `handle_redirect` を呼び出す。
  3. その他の場合:
     - `build_combined_word` を呼び出し、単語トークンを生成する。
     - 生成された単語が空でなければ、トークンリストに追加する。

## 関数: lexer
- **引数**:
  - `input`: 入力文字列
  - `data`: シェルの主要データ構造体
- **処理**:
  1. トークンリスト `tokens` を `NULL` に初期化する。
  2. 入力文字列の終わりまでループする:
     - 空白をスキップする。
     - 文字があれば `process_token` を呼び出し、トークンを生成・追加する。
  3. トークンリストを返す。

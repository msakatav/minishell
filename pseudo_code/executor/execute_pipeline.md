# execute_pipeline.c 疑似コード

## 関数: exec_external_in_child
- **概要**:
  - 子プロセス内で外部コマンドを実行する（パス検索、権限チェック、execve）。
- **引数**:
  - `cmd`: 現在のコマンド
  - `data`: シェルの主要データ構造体
- **処理**:
  1. `find_executable` を呼び出し、コマンドの絶対パスを取得する。
  2. パスが見つからない場合:
     - エラーメッセージ "command not found" を出力する。
     - `cleanup_data` を呼び出し、メモリを解放する。
     - ステータス `127` で終了 (`exit`) する。
  3. 実行権限がない場合 (`access(path, X_OK) != 0`):
     - エラーメッセージ "Permission denied" を出力する。
     - パスのメモリを解放する。
     - `cleanup_data` を呼び出し、メモリを解放する。
     - ステータス `126` で終了 (`exit`) する。
  4. `env_to_array` を呼び出し、環境変数を配列形式に変換する。
  5. `execve` を呼び出し、コマンドを実行する。
  6. `execve` が失敗した場合:
     - `cleanup_data` を呼び出し、メモリを解放する。
     - ステータス `126` で終了 (`exit`) する。

## 関数: setup_child_pipes
- **概要**:
  - 子プロセスのパイプ入出力を設定する。
- **引数**:
  - `cmd`: 現在のコマンド
  - `prev`: 前のパイプのファイルディスクリプタ配列
  - `pfd`: 現在のパイプのファイルディスクリプタ配列
- **処理**:
  1. 前のパイプが存在する場合 (`prev[0] != -1`):
     - `dup2` で `prev[0]` を標準入力 (`STDIN_FILENO`) に複製する。
     - `prev` の両端 (`prev[0]`, `prev[1]`) を閉じる。
  2. 次のコマンドが存在する場合 (`cmd->next`):
     - `pfd[0]` (読み込み側) を閉じる。
     - `dup2` で `pfd[1]` を標準出力 (`STDOUT_FILENO`) に複製する。
     - `pfd[1]` (書き込み側) を閉じる。

## 関数: execute_child
- **概要**:
  - パイプとリダイレクトを設定し、コマンド（ビルトインまたは外部）を実行する。
- **引数**:
  - `cmd`: 現在のコマンド
  - `data`: シェルの主要データ構造体
  - `prev`: 前のパイプのファイルディスクリプタ配列
  - `pfd`: 現在のパイプのファイルディスクリプタ配列
- **処理**:
  1. `setup_child_pipes` を呼び出し、パイプを設定する。
  2. `setup_redirections` を呼び出し、リダイレクトを設定する。
     - 失敗した場合、`cleanup_data` を呼び出し、ステータス `1` で終了 (`exit`) する。
  3. `SIGINT` と `SIGQUIT` のハンドラをデフォルト (`SIG_DFL`) に戻す。
  4. コマンドがビルトインの場合:
     - `execute_builtin` を呼び出し、その戻り値を保存する。
     - `cleanup_data` を呼び出し、メモリを解放する。
     - 保存した戻り値で終了 (`exit`) する。
  5. 外部コマンドの場合:
     - `exec_external_in_child` を呼び出し、外部コマンドを実行する。

## 関数: process_pipeline_cmd
- **概要**:
  - パイプを作成し、フォークして子プロセスでコマンドを実行する。
- **引数**:
  - `cmd`: 現在のコマンド
  - `data`: シェルの主要データ構造体
  - `prev`: 前のパイプのファイルディスクリプタ配列
  - `pfd`: 現在のパイプのファイルディスクリプタ配列
- **戻り値**:
  - 子プロセスのPID
- **処理**:
  1. 次のコマンドがある場合、`pipe` を作成する。失敗したらエラーを出力して `-1` を返す。
  2. `fork` で子プロセスを作成する。
  3. 子プロセスの場合:
     - `execute_child` を呼び出し、コマンドを実行する。
  4. 親プロセスの場合:
     - `handle_parent_pipeline` を呼び出し、パイプの管理を行う。
  5. プロセスIDを返す。

## 関数: execute_pipeline
- **引数**:
  - `cmds`: コマンドリスト
  - `data`: シェルの主要データ構造体
- **処理**:
  1. `prev_pipe` を `-1` で初期化する。
  2. `count_cmds` でコマンド数をカウントする。
  3. コマンドリストを走査するループ:
     - `process_pipeline_cmd` を呼び出し、コマンド処理とフォークを行う。
     - 返されたPIDを `last_pid` に保存する。
     - 次のコマンドへ進む。
  4. ループ終了後、残っている `prev_pipe` を閉じる。
  5. `wait_for_children` を呼び出し、すべての子プロセスの終了を待機する。
